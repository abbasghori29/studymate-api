"""
Chat endpoint for RAG-powered chatbot with memory.
Supports anonymous user identification for personalized memory.
"""
from fastapi import APIRouter, HTTPException, status, Depends
from typing import List, Optional

from app.schemas.chat import ChatRequest, ChatResponse, ChatMessage, MemoryStats, UserStats
from app.services.chatbot import get_chatbot_service, ChatbotService, get_memory_service, MEMORY_TYPE

router = APIRouter()


def get_chatbot() -> ChatbotService:
    """Dependency to get chatbot service"""
    try:
        return get_chatbot_service()
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"Chatbot service unavailable: {str(e)}"
        )


@router.post("/", response_model=ChatResponse)
async def chat(
    request: ChatRequest,
    chatbot: ChatbotService = Depends(get_chatbot),
):
    """
    Chat with the RAG-powered CAFS assistant
    
    - **question**: Your question about courses, certifications, etc.
    - **user_id**: Anonymous user ID for personalized memory (generated by client)
    - **session_id**: Session ID for grouping conversations
    - **chat_history**: Optional previous messages for context
    - **k**: Number of documents to retrieve (1-20, default: 5)
    - **use_memory**: Search past conversations for context (default: true)
    - **store_in_memory**: Save this conversation to memory (default: true)
    
    Returns answer, sources, and memory usage info.
    """
    try:
        # Convert chat history format if provided
        chat_history = None
        if request.chat_history:
            chat_history = [
                (msg.role, msg.content)
                for msg in request.chat_history
            ]
        
        # Get response from chatbot with user context
        result = chatbot.chat(
            question=request.question,
            chat_history=chat_history,
            k=request.k,
            use_memory=request.use_memory,
            store_in_memory=request.store_in_memory,
            user_id=request.user_id,
            session_id=request.session_id,
        )
        
        return ChatResponse(**result)
        
    except ValueError as e:
        # Configuration errors
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"Configuration error: {str(e)}"
        )
    except FileNotFoundError as e:
        # Vector store not found
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"Vector store not found: {str(e)}"
        )
    except Exception as e:
        # Log the full error for debugging
        import traceback
        error_detail = str(e)
        print(f"Chat error: {error_detail}")
        print(traceback.format_exc())
        
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error processing chat request: {error_detail}"
        )


@router.get("/health")
async def health_check(chatbot: ChatbotService = Depends(get_chatbot)):
    """Check if chatbot service is healthy"""
    memory_stats = {}
    try:
        memory = get_memory_service()
        memory_stats = memory.get_stats()
    except:
        memory_stats = {"total_conversations": 0, "index_size": 0}
    
    return {
        "status": "healthy",
        "vector_store_loaded": chatbot.vector_store is not None,
        "llm_initialized": chatbot.llm is not None,
        "memory_initialized": chatbot.memory is not None,
        "memory_type": MEMORY_TYPE,  # "pinecone" or "faiss"
        "documents_count": len(chatbot.vector_store.index_to_docstore_id) if chatbot.vector_store else 0,
        "memory_stats": memory_stats,
    }


@router.get("/memory/stats", response_model=MemoryStats)
async def get_memory_stats():
    """Get memory statistics"""
    try:
        memory = get_memory_service()
        stats = memory.get_stats()
        return MemoryStats(**stats)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting memory stats: {str(e)}"
        )


@router.delete("/memory/clear")
async def clear_memory():
    """Clear all memory (past conversations)"""
    try:
        if MEMORY_TYPE == "pinecone":
            # Clear Pinecone index
            memory = get_memory_service()
            success = memory.clear_all_memory()
            if not success:
                raise Exception("Failed to clear Pinecone memory")
        else:
            # Clear FAISS local files
            import os
            import shutil
            
            memory_path = "memory_index"
            user_memory_path = "user_memories"
            
            if os.path.exists(memory_path):
                shutil.rmtree(memory_path)
            if os.path.exists(user_memory_path):
                shutil.rmtree(user_memory_path)
            
            # Reset the singleton
            from app.services import memory
            memory._memory_service = None
        
        return {"status": "success", "message": f"Memory cleared successfully ({MEMORY_TYPE})"}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error clearing memory: {str(e)}"
        )


@router.get("/user/{user_id}/stats", response_model=UserStats)
async def get_user_stats(user_id: str):
    """Get statistics for a specific anonymous user"""
    try:
        memory = get_memory_service()
        stats = memory.get_user_stats(user_id)
        return UserStats(**stats)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting user stats: {str(e)}"
        )


@router.get("/user/{user_id}/history")
async def get_user_history(user_id: str, limit: int = 20):
    """Get conversation history for a specific anonymous user"""
    try:
        memory = get_memory_service()
        history = memory.get_user_history(user_id, limit=limit)
        return {"user_id": user_id, "conversations": history, "count": len(history)}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting user history: {str(e)}"
        )


@router.get("/user/{user_id}/session/{session_id}")
async def get_session_history(user_id: str, session_id: str):
    """Get conversation history for a specific session"""
    try:
        memory = get_memory_service()
        history = memory.get_session_history(user_id, session_id)
        return {
            "user_id": user_id, 
            "session_id": session_id, 
            "conversations": history,
            "count": len(history)
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting session history: {str(e)}"
        )


@router.delete("/user/{user_id}/clear")
async def clear_user_memory(user_id: str):
    """Clear all memory for a specific user"""
    try:
        memory = get_memory_service()
        success = memory.clear_user_memory(user_id)
        if success:
            return {"status": "success", "message": f"Memory cleared for user {user_id}"}
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to clear user memory"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error clearing user memory: {str(e)}"
        )

